<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Generator V3</title>
    <!-- Favicon Update -->
    <link rel="icon" href="https://cdn.fusedframe.co.uk/main-logos/png/Square%20Favicon%20(No%20Circle).png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- EXIF-JS for client-side EXIF data extraction -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    
    <style>
        /* Define Fused Frame Photography Branding Colors and Fonts */
        :root {
            --bg-dark: #111827;
            --bg-medium: #1e374d;
            --accent: #94fdf8;
            --text-light: #e5e7eb;
        }

        @font-face {
            font-family: 'Aptos Regular';
            src: url('https://cdn.fusedframe.co.uk/fonts/aptos/aptos-regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Aptos Bold';
            src: url('https://cdn.fusedframe.co.uk/fonts/aptos/aptos-bold.woff2') format('woff2');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }

        body {
            background-color: var(--bg-dark);
            font-family: 'Aptos Regular', sans-serif;
            color: var(--text-light);
        }

        h1, h2, h3, .header-text {
            font-family: 'Aptos Bold', sans-serif;
            color: var(--accent);
        }

        .container-bg {
            background-color: var(--bg-medium);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }
        
        /* Custom range track styling */
        input[type="range"]::-webkit-slider-runnable-track {
            background: var(--bg-dark);
            border-radius: 4px;
            height: 8px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            margin-top: -5px; 
        }

        /* Styling for the new icon SVGs (colored to accent) */
        .icon-svg {
            stroke: var(--accent);
            stroke-width: 1.5;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            width: 28px;
            height: 28px;
            min-width: 28px;
            /* Added smooth transition for hover effects */
            transition: stroke 0.1s; 
        }

        .overlay-text-item {
            cursor: pointer;
            transition: background-color 0.1s;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .overlay-text-item:hover {
            background-color: rgba(148, 253, 248, 0.1);
        }
        .overlay-text-item:hover .icon-svg {
            stroke: var(--text-light); /* Slight change on hover */
        }

        /* The invisible input that overlays the text */
        #editInput {
            position: absolute;
            z-index: 20;
            opacity: 0; /* Starts invisible */
            padding: 0;
            margin: 0;
            border: none;
            resize: none;
            background: rgba(0,0,0,0);
            color: var(--text-light);
            font-family: 'Aptos Bold', sans-serif;
            pointer-events: none; /* Initially non-interactive */
        }

        /* Custom confirmation box styling */
        #customAlert {
            z-index: 50;
            background-color: var(--bg-medium);
            border: 1px solid var(--accent);
            box-shadow: 0 10px 15px rgba(0,0,0,0.5);
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.2s ease-out;
            pointer-events: none;
        }
        #customAlert.active {
            transform: scale(1);
            opacity: 1;
            pointer-events: auto;
        }
        
    </style>
    <!-- Configure Tailwind to use custom colors -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'bg-dark': 'var(--bg-dark)',
                        'bg-medium': 'var(--bg-medium)',
                        'accent': 'var(--accent)',
                        'text-light': 'var(--text-light)',
                    },
                    fontFamily: {
                        'aptos-regular': ['Aptos Regular', 'sans-serif'],
                        'aptos-bold': ['Aptos Bold', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-8 min-h-screen flex flex-col">

    <!-- Custom Alert/Message Box for non-alert() messages -->
    <div id="customAlert" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-6 rounded-xl max-w-sm text-center">
        <p id="alertMessage" class="mb-4 text-text-light font-semibold"></p>
        <button id="alertClose" class="py-2 px-4 bg-accent text-bg-dark rounded-lg font-bold hover:opacity-90">OK</button>
    </div>

    <div class="max-w-7xl mx-auto flex-grow w-full">
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl mb-2">Overlay Generator</h1>
            <p class="text-lg md:text-xl text-text-light font-light opacity-80">A blurred version of your image with camera settings overlayed, free to use.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <!-- 1. Settings Panel (Sidebar) -->
            <div id="settingsPanel" class="lg:col-span-1 container-bg p-6 rounded-xl space-y-6 lg:h-fit lg:sticky lg:top-8 order-2 lg:order-1">
                <h3 class="header-text text-2xl mb-4">1. Image & Global Settings</h3>
                
                <!-- Image Upload -->
                <div class="space-y-3">
                    <label class="block text-text-light font-bold">Upload Images (Multi-select enabled)</label>
                    <input type="file" id="imageUpload" accept="image/jpeg, image/png, image/webp" multiple class="w-full text-text-light text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-accent file:text-bg-dark hover:file:bg-opacity-90">
                </div>

                <!-- Clear Images Button -->
                <div class="pt-2">
                    <button id="clearImagesButton" class="w-full py-2 bg-red-800 text-white font-semibold rounded-xl shadow-lg hover:bg-red-700 transition disabled:opacity-50" disabled>
                        Clear All Loaded Images
                    </button>
                </div>

                <!-- Navigation -->
                <div id="navContainer" class="flex items-center justify-between mt-4 py-2 border-y border-bg-dark" style="display: none;">
                    <button id="prevImage" class="p-2 rounded-full bg-bg-dark text-accent hover:bg-bg-medium disabled:opacity-30">
                        <!-- SVG Arrow Left -->
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                    </button>
                    <span id="imageCounter" class="text-text-light font-bold"></span>
                    <button id="nextImage" class="p-2 rounded-full bg-bg-dark text-accent hover:bg-bg-medium disabled:opacity-30">
                        <!-- SVG Arrow Right -->
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
                    </button>
                </div>

                <!-- Adjustment Sliders -->
                <div class="space-y-4">
                    <h4 class="header-text text-xl pt-4">Visual Adjustments (Saved Locally)</h4>
                    <div>
                        <label for="blurAmount" class="block text-text-light">Background Blur Strength (<span id="blurValue">10</span>px)</label>
                        <input type="range" id="blurAmount" min="0" max="40" value="10" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="overlayOpacity" class="block text-text-light">Overlay Darkening (Text Clarity)</label>
                        <input type="range" id="overlayOpacity" min="0.0" max="0.6" value="0.2" step="0.05" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label for="textScale" class="block text-text-light">Text Scale (<span id="scaleValue">1.0</span>x)</label>
                        <input type="range" id="textScale" min="0.5" max="2.0" value="1.0" step="0.1" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>

                <!-- Download Options -->
                <div class="pt-4 space-y-2">
                    <button id="downloadCurrentButton" class="w-full py-3 bg-accent text-bg-dark font-bold text-lg rounded-xl shadow-lg hover:opacity-90 transition disabled:opacity-50" disabled>
                        Download Current Image
                    </button>
                    <button id="downloadAllButton" class="w-full py-2 bg-bg-dark border border-accent text-accent font-semibold rounded-xl shadow-lg hover:bg-bg-medium transition disabled:opacity-50" disabled>
                        Download All Images
                    </button>
                    <p id="downloadMessage" class="text-sm text-center text-red-400 mt-2 hidden"></p>
                </div>
            </div>

            <!-- 2. Live Preview & Toggles -->
            <div class="lg:col-span-2 order-1 lg:order-2">
                
                <!-- Toggles for Optional Fields -->
                <div id="toggleControls" class="container-bg p-4 rounded-xl mb-4" style="display: none;">
                    <h4 class="header-text text-xl mb-3">Overlay Visibility Toggles</h4>
                    <div class="flex flex-wrap gap-4 text-sm">
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="toggleLensModel" class="form-checkbox text-accent bg-bg-dark border-bg-dark rounded" checked>
                            <span class="text-text-light">Lens Model</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="toggleDescription" class="form-checkbox text-accent bg-bg-dark border-bg-dark rounded" checked>
                            <span class="text-text-light">Description</span>
                        </label>
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input type="checkbox" id="toggleCopyright" class="form-checkbox text-accent bg-bg-dark border-bg-dark rounded" checked>
                            <span class="text-text-light">Copyright</span>
                        </label>
                    </div>
                </div>
                
                <!-- Live Preview Area -->
                <div id="previewContainerWrapper" class="relative w-full aspect-video rounded-xl shadow-2xl overflow-hidden bg-bg-medium flex items-center justify-center min-h-[300px]">
                    <p id="uploadPrompt" class="text-center p-8 text-text-light opacity-70">Upload images to start generating the overlay.</p>
                    
                    <div id="previewContainer" class="absolute inset-0 w-full h-full" style="display: none;">
                        <img id="displayImage" class="absolute inset-0 w-full h-full object-cover" style="filter: blur(10px);" alt="Blurred Preview Image">
                        
                        <!-- Darkening Overlay -->
                        <div id="darkOverlay" class="absolute inset-0 w-full h-full" style="background-color: rgba(17, 24, 39, 0.2);"></div>
                        
                        <!-- Invisible Input for Direct Editing -->
                        <textarea id="editInput" rows="1" class="absolute" style="font-size: 30px;"></textarea>

                        <!-- Overlay Text Content -->
                        <div id="overlayContent" class="absolute inset-0 p-4 sm:p-8 md:p-10 lg:p-12" style="font-family: 'Aptos Bold', sans-serif;">
                            <div id="settingsList" class="space-y-4 text-text-light text-lg md:text-xl lg:text-2xl">
                                <!-- Technical Details go here (Aperture, Shutter, ISO, Focal) -->
                            </div>

                            <!-- Separator Line (Always visible if image is loaded) -->
                            <div id="separator" class="h-px w-full bg-accent opacity-50 my-6"></div>

                            <!-- Camera & Copyright Info -->
                            <div id="infoList" class="space-y-3 text-text-light text-base md:text-lg lg:text-xl opacity-90">
                                <!-- Description, Camera, Lens, Copyright go here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Hidden Canvas for Download Generation -->
                <canvas id="hiddenCanvas" style="display: none;"></canvas>
            </div>
        </main>
        
        <!-- Footer -->
        <footer class="mt-12 text-center text-sm text-text-light opacity-70 border-t border-bg-medium pt-4">
            <p>Any content you upload, never leaves your device.</p>
            <p class="font-bold mt-1">Made by Adlai Dyson | Fused Frame Photography</p>
        </footer>
    </div>

    <!-- Icon SVGs (Inline Definition) - Replacing previous ones with new conceptual designs -->
    <script>
        // Note: These SVGs replace the previous ones to reflect the user's new file names and request
        // for an updated look (colored to #94fdf8 via the .icon-svg class).
        const ICONS = {
            // New ISO Icon: A simple photo-sensor/chip
            iso: `<svg class="icon-svg" viewBox="0 0 24 24"><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6"/><path d="M4 12h16"/><rect x="4" y="12" width="16" height="8" rx="2" ry="2"/><circle cx="12" cy="16" r="2"/></svg>`,
            // New Speech/Description Icon: Speech Bubble/Note
            description: `<svg class="icon-svg" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>`,
            // New Camera Make/Model Icon
            cameraMakeModel: `<svg class="icon-svg" viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3L14.5 4z"/><circle cx="12" cy="13" r="3"/></svg>`,
            // New Lens Model Icon
            lensModel: `<svg class="icon-svg" viewBox="0 0 24 24"><path d="M12 2a4 4 0 0 0-4 4v2H4a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-4V6a4 4 0 0 0-4-4zM12 2v20"/><path d="M12 10l5-5M12 10l-5-5"/></svg>`,
            // Focal Length Icon: Focus/Ruler
            focalLength: `<svg class="icon-svg" viewBox="0 0 24 24"><path d="M16 16.5V10l6-6M8 8V2h8"/><path d="M10 10v4a2 2 0 0 0 2 2h4"/></svg>`,
            // Exposure (Shutter Speed) Icon: Shutter Blade
            shutterSpeed: `<svg class="icon-svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 2v10l-6 6M12 12l6 6M12 12l-6-6M12 12l6-6M12 22l-6-6M12 22l6-6"/></svg>`,
            // Aperture Icon: F-Stop blades
            aperture: `<svg class="icon-svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 2v20M4.9 4.9l14.1 14.1M4.9 19.1l14.1-14.1M2 12h20M7.5 16.5l9-9M7.5 7.5l9 9"/></svg>`,
            // Copyright Icon (Unchanged)
            copyright: `<svg class="icon-svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" /><path d="M14.5 9.5a3.5 3.5 0 1 0 0 5H12" /></svg>`,
        };
    </script>

    <script>
        const imageUpload = document.getElementById('imageUpload');
        const displayImage = document.getElementById('displayImage');
        const overlayContent = document.getElementById('overlayContent');
        const downloadCurrentButton = document.getElementById('downloadCurrentButton');
        const downloadAllButton = document.getElementById('downloadAllButton');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const downloadMessage = document.getElementById('downloadMessage');
        const darkOverlay = document.getElementById('darkOverlay');
        const settingsList = document.getElementById('settingsList');
        const infoList = document.getElementById('infoList');
        const uploadPrompt = document.getElementById('uploadPrompt');
        const previewContainer = document.getElementById('previewContainer');
        const editInput = document.getElementById('editInput');
        const toggleControls = document.getElementById('toggleControls');
        const navContainer = document.getElementById('navContainer');
        const prevImage = document.getElementById('prevImage');
        const nextImage = document.getElementById('nextImage');
        const imageCounter = document.getElementById('imageCounter');
        const clearImagesButton = document.getElementById('clearImagesButton');
        const separator = document.getElementById('separator');

        // Custom Alert/Message Box elements
        const customAlert = document.getElementById('customAlert');
        const alertMessage = document.getElementById('alertMessage');
        const alertClose = document.getElementById('alertClose');
        
        const ctx = hiddenCanvas.getContext('2d');

        // State Management
        let imageProjects = [];
        let currentImageIndex = 0;
        let activeEditElement = null; // Stores the DOM element currently being edited

        const DEFAULT_SETTINGS = {
            aperture: 'f/2',
            shutterSpeed: '1/800 sec',
            iso: 'ISO 160',
            focalLength: '90.0mm (135.0mm FF)',
            cameraMakeModel: 'FUJIFILM X-T3',
            lensModel: 'FUJIFILM XF90mmF2 R LM WR',
            description: 'Natural light at my local park',
            copyright: 'Â© Adlai Dyson | Fused Frame Photography',
            // Toggles
            showLensModel: true,
            showDescription: true,
            showCopyright: true,
        };
        
        // Global Adjustment Sliders (Persisted)
        const globalAdjustments = {
            blur: 10,
            opacity: 0.2,
            scale: 1.0
        };

        // DOM elements for sliders
        const controls = {
            blurAmount: document.getElementById('blurAmount'),
            overlayOpacity: document.getElementById('overlayOpacity'),
            textScale: document.getElementById('textScale'),
            blurValue: document.getElementById('blurValue'),
            scaleValue: document.getElementById('scaleValue'),
            toggleLensModel: document.getElementById('toggleLensModel'),
            toggleDescription: document.getElementById('toggleDescription'),
            toggleCopyright: document.getElementById('toggleCopyright'),
        };

        // --- Custom Alert Implementation (Replacing alert()) ---
        const showCustomAlert = (message) => {
            alertMessage.textContent = message;
            customAlert.classList.add('active');
            alertClose.focus();
        };

        const hideCustomAlert = () => {
            customAlert.classList.remove('active');
        };

        alertClose.addEventListener('click', hideCustomAlert);


        // --- Local Storage Functions ---

        /**
         * Saves global adjustment settings to localStorage.
         */
        const saveAdjustments = () => {
            try {
                localStorage.setItem('overlaySettings', JSON.stringify(globalAdjustments));
            } catch (e) {
                console.error("Could not save settings to localStorage.", e);
            }
        };

        /**
         * Loads global adjustment settings from localStorage and updates DOM.
         */
        const loadAdjustments = () => {
            try {
                const saved = localStorage.getItem('overlaySettings');
                if (saved) {
                    const loaded = JSON.parse(saved);
                    Object.assign(globalAdjustments, loaded);
                }
                
                // Update DOM elements for visibility even if no image is loaded
                controls.blurAmount.value = globalAdjustments.blur;
                controls.overlayOpacity.value = globalAdjustments.opacity;
                controls.textScale.value = globalAdjustments.scale;
                controls.blurValue.textContent = globalAdjustments.blur;
                controls.scaleValue.textContent = globalAdjustments.scale.toFixed(1);

            } catch (e) {
                console.error("Could not load settings from localStorage.", e);
            }
        };


        // --- EXIF Parsing Helpers ---

        const parseExifValue = (value) => {
            if (Array.isArray(value) && value.length === 2 && value[0] !== 0) {
                return value[0] / value[1];
            }
            return value;
        };

        const formatShutterSpeed = (value) => {
            if (value === 0) return '';
            if (value >= 1.0) return `${value.toFixed(1).replace(/\.0$/, '')} sec`;
            const reciprocal = 1 / value;
            const roundedReciprocal = Math.round(reciprocal);
            return `1/${roundedReciprocal} sec`;
        };

        const extractExifData = (tags) => {
            const data = { ...DEFAULT_SETTINGS }; // Start with defaults
            
            const apertureRaw = parseExifValue(tags.FNumber);
            if (apertureRaw) data.aperture = `f/${apertureRaw.toFixed(1).replace('.0', '')}`;
            
            const ssRaw = parseExifValue(tags.ExposureTime);
            if (ssRaw) data.shutterSpeed = formatShutterSpeed(ssRaw);

            if (tags.ISOSpeedRatings) data.iso = `ISO ${tags.ISOSpeedRatings}`;
            
            const focalRaw = parseExifValue(tags.FocalLength);
            if (focalRaw) {
                let focalValue = `${focalRaw.toFixed(1).replace('.0', '')}mm`;
                if (tags.FocalLengthIn35mmFilm) {
                    focalValue += ` (${tags.FocalLengthIn35mmFilm}mm FF)`;
                }
                data.focalLength = focalValue;
            }

            data.cameraMakeModel = tags.Make && tags.Model ? `${tags.Make} ${tags.Model}`.trim() : 'Unknown Camera';
            data.lensModel = tags.LensModel || DEFAULT_SETTINGS.lensModel;
            data.description = tags.ImageDescription || DEFAULT_SETTINGS.description;
            data.copyright = tags.Copyright || DEFAULT_SETTINGS.copyright;
            
            return data;
        };

        // --- Rendering & Update Functions ---

        /**
         * Renders the current image and overlay data to the live preview.
         */
        const renderCurrentProject = () => {
            if (imageProjects.length === 0) {
                previewContainer.style.display = 'none';
                uploadPrompt.style.display = 'block';
                navContainer.style.display = 'none';
                toggleControls.style.display = 'none';
                downloadCurrentButton.disabled = true;
                downloadAllButton.disabled = true;
                clearImagesButton.disabled = true;
                separator.style.display = 'none'; // Hide separator when no image
                return;
            }

            const project = imageProjects[currentImageIndex];
            const data = project.data;
            
            // 1. Image and Blur
            displayImage.src = project.src;
            displayImage.style.filter = `blur(${globalAdjustments.blur}px)`;
            
            // Set aspect ratio
            const ratio = project.image.naturalWidth / project.image.naturalHeight;
            document.getElementById('previewContainerWrapper').style.aspectRatio = ratio;

            // 2. Adjustments (Update DOM elements with saved values)
            controls.blurValue.textContent = globalAdjustments.blur;
            controls.scaleValue.textContent = globalAdjustments.scale.toFixed(1);
            darkOverlay.style.backgroundColor = `rgba(17, 24, 39, ${globalAdjustments.opacity})`;

            // 3. Toggles
            controls.toggleLensModel.checked = data.showLensModel;
            controls.toggleDescription.checked = data.showDescription;
            controls.toggleCopyright.checked = data.showCopyright;

            // 4. Update Navigation & Buttons
            imageCounter.textContent = `Image ${currentImageIndex + 1} of ${imageProjects.length}`;
            prevImage.disabled = currentImageIndex === 0;
            nextImage.disabled = currentImageIndex === imageProjects.length - 1;
            navContainer.style.display = imageProjects.length > 1 ? 'flex' : 'none';
            toggleControls.style.display = 'block';
            downloadCurrentButton.disabled = false;
            downloadAllButton.disabled = false;
            clearImagesButton.disabled = false;
            previewContainer.style.display = 'block';
            uploadPrompt.style.display = 'none';
            separator.style.display = 'block'; // Always show separator if image is loaded

            // 5. Build HTML Overlay Content
            settingsList.innerHTML = '';
            infoList.innerHTML = '';

            // Technical Settings
            const techSettings = [
                { key: 'aperture', icon: ICONS.aperture },
                { key: 'shutterSpeed', icon: ICONS.shutterSpeed },
                { key: 'iso', icon: ICONS.iso },
                { key: 'focalLength', icon: ICONS.focalLength },
            ];

            techSettings.forEach(({ key, icon }) => {
                settingsList.innerHTML += `
                    <div class="flex items-center space-x-4 overlay-text-item" data-field="${key}">
                        ${icon}
                        <span data-display="${key}">${data[key]}</span>
                    </div>
                `;
            });

            // Info Settings (Optional Fields)
            
            // Description
            infoList.innerHTML += `
                <div class="flex items-center space-x-4 overlay-text-item ${data.showDescription ? '' : 'hidden'}" data-field="description">
                    ${ICONS.description.replace('icon-svg', 'icon-svg h-6 w-6')}
                    <span data-display="description">${data.description}</span>
                </div>
            `;
            
            // Camera Make/Model (Always shown if image loaded)
            infoList.innerHTML += `
                <div class="flex items-center space-x-4 overlay-text-item" data-field="cameraMakeModel">
                    ${ICONS.cameraMakeModel.replace('icon-svg', 'icon-svg h-6 w-6')}
                    <span data-display="cameraMakeModel">${data.cameraMakeModel}</span>
                </div>
            `;
            
            // Lens Model
            infoList.innerHTML += `
                <div class="flex items-center space-x-4 overlay-text-item ${data.showLensModel ? '' : 'hidden'}" data-field="lensModel">
                    ${ICONS.lensModel.replace('icon-svg', 'icon-svg h-6 w-6')}
                    <span data-display="lensModel">${data.lensModel}</span>
                </div>
            `;
            
            // Copyright
            infoList.innerHTML += `
                <div class="flex items-center space-x-4 overlay-text-item ${data.showCopyright ? '' : 'hidden'}" data-field="copyright">
                    ${ICONS.copyright.replace('icon-svg', 'icon-svg h-6 w-6')}
                    <span data-display="copyright">${data.copyright}</span>
                </div>
            `;


            // Apply text scale
            overlayContent.style.transform = `scale(${globalAdjustments.scale})`;
            overlayContent.style.transformOrigin = 'top left'; 
            
            // Re-attach edit listeners after content refresh
            setTimeout(() => {
                document.querySelectorAll('.overlay-text-item').forEach(item => {
                    item.addEventListener('click', handleTextEditStart);
                });
            }, 0);
        };


        /**
         * Draws a single image onto the canvas with its overlay and triggers download.
         * @param {number} index - Index of the project to download.
         */
        const drawAndDownloadImage = (index) => {
            return new Promise(resolve => {
                const project = imageProjects[index];
                const data = project.data;
                const image = project.image;
                const mimeType = project.mimeType; // Use original MIME type for download
                const extension = mimeType.split('/')[1];
                const quality = (mimeType === 'image/jpeg') ? 0.9 : 1.0;

                // Set canvas dimensions to match the original image size
                hiddenCanvas.width = image.naturalWidth;
                hiddenCanvas.height = image.naturalHeight;
                
                // --- 1. Draw Original Image (No blur needed for final download) ---
                ctx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);
                ctx.drawImage(image, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                
                // Draw Darkening Overlay
                ctx.fillStyle = `rgba(17, 24, 39, ${globalAdjustments.opacity})`;
                ctx.fillRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                // --- 2. Draw Text Overlay ---

                const scaleFactor = globalAdjustments.scale;
                const baseFontSize = hiddenCanvas.height / 35; 
                const fontSize = baseFontSize * scaleFactor;
                const lineHeight = fontSize * 1.6;
                const padding = hiddenCanvas.width / 20; 

                ctx.textBaseline = 'middle';

                let currentY = padding;

                // Helper function to draw text lines with a colored square icon placeholder
                const drawCanvasTextLine = (text, fontStyle = 'Bold', customFontSizeMultiplier = 1) => {
                    if (!text) return; // Skip if text is empty
                    
                    const textDisplay = String(text);
                    const currentFontSize = fontSize * customFontSizeMultiplier;
                    const iconSize = currentFontSize * 1.2;
                    
                    // Icon Placeholder: Draw a square in the accent color
                    ctx.fillStyle = 'var(--accent)'; 
                    ctx.fillRect(padding, currentY + (currentFontSize * 0.5 - iconSize * 0.45), iconSize * 0.9, iconSize * 0.9);
                    
                    // Draw Text
                    ctx.fillStyle = 'var(--text-light)';
                    ctx.font = `${fontStyle} ${currentFontSize}px 'Aptos Bold', sans-serif`; 
                    ctx.fillText(textDisplay, padding + iconSize * 1.5, currentY + currentFontSize * 0.5);

                    currentY += lineHeight * customFontSizeMultiplier;
                };
                
                // Technical Settings (Using only the text since drawing SVGs on canvas is complex)
                drawCanvasTextLine(data.aperture);
                drawCanvasTextLine(data.shutterSpeed);
                drawCanvasTextLine(data.iso);
                drawCanvasTextLine(data.focalLength);

                currentY += lineHeight / 2;

                // Separator Line
                ctx.strokeStyle = 'rgba(148, 253, 248, 0.5)';
                ctx.lineWidth = hiddenCanvas.height / 300; 
                ctx.beginPath();
                ctx.moveTo(padding, currentY);
                ctx.lineTo(hiddenCanvas.width - padding, currentY);
                ctx.stroke();
                currentY += lineHeight / 2;

                // Info Settings
                if (data.showDescription && data.description) {
                    drawCanvasTextLine(data.description, 'Normal', 0.9);
                }

                // Camera Model
                drawCanvasTextLine(data.cameraMakeModel, 'Normal', 0.9);

                // Lens Model
                if (data.showLensModel && data.lensModel) {
                    drawCanvasTextLine(data.lensModel, 'Normal', 0.9);
                }

                // Copyright
                if (data.showCopyright && data.copyright) {
                    drawCanvasTextLine(data.copyright, 'Normal', 0.9);
                }


                // --- 3. Trigger Download ---
                const dataURL = hiddenCanvas.toDataURL(mimeType, quality);
                const a = document.createElement('a');
                a.href = dataURL;
                a.download = `fusedframe-${index + 1}-${project.image.name}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                resolve(); // Resolve the promise once download is triggered
            });
        };

        // --- Direct Editing Logic ---

        const handleTextEditStart = (event) => {
            const target = event.currentTarget.querySelector('span[data-display]');
            if (!target) return;

            // 1. Hide the input if another element was active
            handleTextEditEnd();

            // 2. Set the active element
            activeEditElement = target;
            const field = event.currentTarget.getAttribute('data-field');
            const project = imageProjects[currentImageIndex];

            // 3. Calculate position and size
            const rect = target.getBoundingClientRect();
            const previewRect = overlayContent.getBoundingClientRect();
            
            // Adjust for the scale transform on the overlayContent
            const scale = globalAdjustments.scale;
            
            // Get un-scaled position relative to the preview container
            const top = (rect.top - previewRect.top) / scale;
            const left = (rect.left - previewRect.left) / scale;
            const width = rect.width / scale;
            const height = rect.height / scale;

            // 4. Configure and show the invisible input
            editInput.value = project.data[field];
            editInput.setAttribute('data-field', field);
            editInput.style.pointerEvents = 'auto';
            editInput.style.opacity = 1;
            editInput.style.top = `${top}px`;
            editInput.style.left = `${left}px`;
            editInput.style.width = `${width + 10}px`; // Add padding/margin
            editInput.style.height = `${height + 5}px`;
            editInput.style.fontSize = `${rect.height}px`; // Match text size
            editInput.style.fontFamily = target.closest('#settingsList') ? 'Aptos Bold, sans-serif' : 'Aptos Regular, sans-serif';

            // 5. Focus and Listen
            editInput.focus();
            editInput.select();
        };

        const handleTextEditEnd = () => {
            if (!activeEditElement) return;

            const field = editInput.getAttribute('data-field');
            const newValue = editInput.value;
            const project = imageProjects[currentImageIndex];

            // Update the state
            project.data[field] = newValue;

            // Reset the input element
            editInput.style.pointerEvents = 'none';
            editInput.style.opacity = 0;
            editInput.value = '';
            activeEditElement = null;

            // Re-render the view with the new data
            renderCurrentProject();
        };

        // --- Event Listeners and Setup ---

        // 1. Load adjustments on initialization
        loadAdjustments();
        document.addEventListener('DOMContentLoaded', renderCurrentProject);

        // 2. Image Upload Handler
        imageUpload.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;

            // Clear old projects if new files are uploaded
            imageProjects = [];
            currentImageIndex = 0;

            let filesProcessed = 0;

            files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.name = file.name.replace(/\.[^/.]+$/, ""); // Store filename without extension
                    img.onload = () => {
                        const newProject = {
                            src: event.target.result,
                            image: img,
                            mimeType: file.type, // Store original MIME type
                            data: { ...DEFAULT_SETTINGS }, // Initialize with defaults
                        };
                        
                        EXIF.getData(img, function() {
                            const allTags = EXIF.getAllTags(this);
                            if (Object.keys(allTags).length > 0) {
                                newProject.data = extractExifData(allTags);
                            }
                            
                            imageProjects.push(newProject);
                            filesProcessed++;
                            // Only render if it's the first image or if all images are loaded
                            if (filesProcessed === files.length) {
                                renderCurrentProject();
                            }
                        });
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
            // Clear the input value so the same files can be re-uploaded if needed
            e.target.value = '';
        });
        
        // 3. Clear Images Handler
        clearImagesButton.addEventListener('click', () => {
            handleTextEditEnd();
            imageProjects = [];
            currentImageIndex = 0;
            renderCurrentProject();
            showCustomAlert('All loaded images have been cleared from the generator.');
        });

        // 4. Global Adjustment Change (Live Update & Save)
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', () => {
                globalAdjustments.blur = parseInt(controls.blurAmount.value);
                globalAdjustments.opacity = parseFloat(controls.overlayOpacity.value);
                globalAdjustments.scale = parseFloat(controls.textScale.value);
                renderCurrentProject();
                saveAdjustments();
            });
        });

        // 5. Toggle Visibility
        document.querySelectorAll('#toggleControls input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                if (imageProjects.length === 0) return;
                const project = imageProjects[currentImageIndex];
                const fieldKey = e.target.id.replace('toggle', 'show');
                project.data[fieldKey] = e.target.checked;
                renderCurrentProject();
            });
        });

        // 6. Navigation
        prevImage.addEventListener('click', () => {
            handleTextEditEnd(); // End any current editing session
            if (currentImageIndex > 0) {
                currentImageIndex--;
                renderCurrentProject();
            }
        });

        nextImage.addEventListener('click', () => {
            handleTextEditEnd(); // End any current editing session
            if (currentImageIndex < imageProjects.length - 1) {
                currentImageIndex++;
                renderCurrentProject();
            }
        });

        // 7. Direct Edit Input
        editInput.addEventListener('input', () => {
            // Live update the actual DOM span while typing (before saving)
            if (activeEditElement) {
                activeEditElement.textContent = editInput.value;
                // Since the overlay is scaled, we need to correct the input width to match the scaled text size
                const currentTextWidth = activeEditElement.getBoundingClientRect().width;
                editInput.style.width = `${currentTextWidth / globalAdjustments.scale + 10}px`;
            }
        });
        
        editInput.addEventListener('blur', handleTextEditEnd);
        editInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleTextEditEnd();
            }
        });
        
        // 8. Download Single
        downloadCurrentButton.addEventListener('click', async () => {
            handleTextEditEnd();
            if (imageProjects.length === 0) return;
            downloadMessage.textContent = 'Generating and downloading current image...';
            downloadMessage.classList.remove('hidden');
            downloadCurrentButton.disabled = true;
            downloadAllButton.disabled = true;

            await drawAndDownloadImage(currentImageIndex);

            downloadMessage.classList.add('hidden');
            downloadCurrentButton.disabled = false;
            downloadAllButton.disabled = false;
        });

        // 9. Download All
        downloadAllButton.addEventListener('click', async () => {
            handleTextEditEnd();
            if (imageProjects.length < 2) {
                showCustomAlert('Batch download requires uploading more than one image.');
                return;
            }
            downloadMessage.textContent = `Starting batch download of ${imageProjects.length} images. Please wait and check your downloads folder.`;
            downloadMessage.classList.remove('hidden');
            downloadCurrentButton.disabled = true;
            downloadAllButton.disabled = true;

            for (let i = 0; i < imageProjects.length; i++) {
                downloadMessage.textContent = `Downloading image ${i + 1} of ${imageProjects.length}...`;
                await drawAndDownloadImage(i);
                // Pause briefly to ensure browser registers each download prompt/file
                await new Promise(r => setTimeout(r, 500)); 
            }

            downloadMessage.textContent = 'Batch download complete!';
            setTimeout(() => {
                downloadMessage.classList.add('hidden');
                downloadCurrentButton.disabled = false;
                downloadAllButton.disabled = false;
            }, 3000);
        });

    </script>
</body>
</html>